<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tusha, Will You Be My Valentine?</title>
    <style>
      :root { color-scheme: light; }
      * { box-sizing: border-box; }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: radial-gradient(circle at top, #ffe3ec, #ffb7c6 55%, #ff8fa3);
        font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
        color: #4a0e1f;
      }

      .card {
        width: min(92vw, 520px);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 28px;
        padding: 40px 28px 36px;
        box-shadow: 0 20px 60px rgba(74, 14, 31, 0.25);
        text-align: center;
        position: relative;
        overflow: hidden;
        animation: cardAppear 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      @keyframes cardAppear {
        from { opacity: 0; transform: scale(0.9) translateY(20px); }
        to   { opacity: 1; transform: scale(1) translateY(0); }
      }

      h1 {
        margin: 0 0 12px;
        font-size: clamp(1.8rem, 2.6vw, 2.3rem);
        letter-spacing: 0.5px;
      }

      p {
        margin: 0 0 28px;
        font-size: 1.05rem;
        opacity: 0.85;
      }

      .buttons {
        display: flex;
        justify-content: center;
        gap: 12px;
        padding: 8px 0 12px;
        position: relative;
        z-index: 2;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 10px 22px;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        letter-spacing: 0.2px;
        position: relative;
        overflow: hidden;
      }

      .btn-fill {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 0;
        border-radius: inherit;
        transition: width 0.15s ease-out;
        pointer-events: none;
      }
      button.holding .btn-fill {
        width: 100%;
        transition-duration: 1s;
        transition-timing-function: linear;
      }

      .btn-text {
        position: relative;
        z-index: 1;
      }

      #yesBtn .btn-fill {
        background: rgba(255, 255, 255, 0.35);
      }

      #noBtn .btn-fill {
        background: rgba(255, 90, 122, 0.25);
      }

      #yesBtn {
        padding: 12px 26px;
        font-size: 1.05rem;
        background: #ff5a7a;
        color: white;
        box-shadow: 0 6px 15px rgba(255, 90, 122, 0.35);
        transition: transform 0.25s ease, box-shadow 0.25s ease;
      }
      #yesBtn:hover {
        transform: translateY(-2px) scale(1.08);
        box-shadow: 0 10px 25px rgba(255, 90, 122, 0.45);
      }

      /* No button: in flow when in .buttons (side by side); absolute when escaping */
      #noBtn {
        background: white;
        color: #ff5a7a;
        border: 2px solid #ff5a7a;
        box-shadow: 0 4px 10px rgba(255, 90, 122, 0.2);

        transition: left 160ms ease-out, top 160ms ease-out, transform 160ms ease-out;
        will-change: left, top, transform;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      #noBtn.noBtnEscaping {
        position: absolute;
        z-index: 3;
      }

      #message {
        margin-top: 22px;
        font-size: 1.1rem;
        font-weight: 700;
        color: #b0003a;
        min-height: 1.6em;
        position: relative;
        z-index: 2;
      }

      .hint {
        margin-top: 16px;
        font-size: 0.95rem;
        color: #ff5a7a;
        font-style: italic;
        opacity: 0.85;
        position: relative;
        z-index: 2;
      }

      .hearts {
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0.18;
        font-size: 1.6rem;
        border-radius: 28px;
        z-index: 1;
      }
      .hearts span { position: absolute; animation: float 8s linear infinite; }

      @keyframes float {
        0%   { transform: translateY(0) scale(0.9);  opacity: 0; }
        20%  { opacity: 1; }
        50%  { transform: translateY(-60px) scale(1.1); }
        100% { transform: translateY(-120px) scale(1.05); opacity: 0; }
      }

      .heart-burst {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .heart-burst span {
        position: absolute;
        left: 50%;
        top: 50%;
        font-size: 2rem;
        color: #ff5a7a;
        opacity: 0;
        animation: heartBurst 1.1s ease-out forwards;
      }
      @keyframes heartBurst {
        0% {
          transform: translate(-50%, -50%) rotate(var(--angle, 0deg)) translateY(0) scale(0);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) rotate(var(--angle, 0deg)) translateY(-140px) scale(1.6);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <main class="card">
      <div class="hearts" aria-hidden="true">
        <span style="left: 8%; top: 78%; animation-delay: 0s;">&hearts;</span>
        <span style="left: 24%; top: 84%; animation-delay: 1s;">&hearts;</span>
        <span style="left: 60%; top: 82%; animation-delay: 2s;">&hearts;</span>
        <span style="left: 78%; top: 76%; animation-delay: 3s;">&hearts;</span>
      </div>

      <h1>Tusha, will you be my valentine?</h1>
      <p>There is only one correct answer.</p>

      <div class="buttons">
        <button id="yesBtn" type="button"><span class="btn-fill" aria-hidden="true"></span><span class="btn-text">Yes</span></button>
        <button id="noBtn" type="button" aria-label="No"><span class="btn-fill" aria-hidden="true"></span><span class="btn-text">No</span></button>
      </div>

      <div id="message" role="status" aria-live="polite"></div>
      <p class="hint">No seems to be a little shy ðŸ˜ˆ</p>
    </main>

    <div id="heartBurst" class="heart-burst" aria-hidden="true"></div>

    <script>
      const noBtn = document.getElementById("noBtn");
      const yesBtn = document.getElementById("yesBtn");
      const message = document.getElementById("message");
      const card = document.querySelector(".card");

      // Key fix:
      // - Use a larger threshold so you can't "snipe" it in a corner
      // - Remove cooldown that can block escaping at the exact wrong time
      // - Always escape on pointerdown and on pointermove while near
      const PADDING = 14;
      const THRESHOLD = 140;      // bigger = harder to catch
      const MIN_MOVE_DIST = 120;  // ensure it actually relocates away
      const COOLDOWN_MS = 40;     // tiny cooldown to avoid jitter, not enough to "stick"
      let lastMoveAt = 0;

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function getMouseInCard(e) {
        const r = card.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
      }

      function rectInCard(el) {
        const cr = card.getBoundingClientRect();
        const br = el.getBoundingClientRect();
        return {
          left: br.left - cr.left,
          top: br.top - cr.top,
          right: br.right - cr.left,
          bottom: br.bottom - cr.top,
          width: br.width,
          height: br.height
        };
      }

      function distPointToRect(px, py, rect) {
        const cx = clamp(px, rect.left, rect.right);
        const cy = clamp(py, rect.top, rect.bottom);
        return Math.hypot(px - cx, py - cy);
      }

      function safeBounds() {
        const boxW = card.clientWidth;
        const boxH = card.clientHeight;
        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        return {
          boxW,
          boxH,
          btnW,
          btnH,
          minX: PADDING,
          minY: PADDING,
          maxX: boxW - btnW - PADDING,
          maxY: boxH - btnH - PADDING
        };
      }

      function currentPos() {
        const b = safeBounds();
        const left = parseFloat(noBtn.style.left);
        const top = parseFloat(noBtn.style.top);
        return {
          left: Number.isFinite(left) ? left : (b.boxW - b.btnW) / 2,
          top: Number.isFinite(top) ? top : (b.boxH - b.btnH) / 2
        };
      }

      function pickFarCorner(mouseX, mouseY) {
        const b = safeBounds();
        const corners = [
          { x: b.minX, y: b.minY },
          { x: b.maxX, y: b.minY },
          { x: b.minX, y: b.maxY },
          { x: b.maxX, y: b.maxY }
        ];
        // choose the corner farthest from the mouse
        corners.sort((a, c) => {
          const da = (a.x - mouseX) ** 2 + (a.y - mouseY) ** 2;
          const dc = (c.x - mouseX) ** 2 + (c.y - mouseY) ** 2;
          return dc - da;
        });
        return corners[0];
      }

      function pickNextPosition(mouseX, mouseY) {
        const b = safeBounds();
        const cur = currentPos();

        // vector away from cursor (mouse -> button center)
        const centerX = cur.left + b.btnW / 2;
        const centerY = cur.top + b.btnH / 2;

        let dx = centerX - mouseX;
        let dy = centerY - mouseY;

        const len = Math.hypot(dx, dy) || 1;
        dx /= len;
        dy /= len;

        // strong push away + randomness
        const step = 190;
        const jitter = 45;

        let nextX = cur.left + dx * step + (Math.random() * 2 - 1) * jitter;
        let nextY = cur.top + dy * step + (Math.random() * 2 - 1) * jitter;

        nextX = clamp(nextX, b.minX, b.maxX);
        nextY = clamp(nextY, b.minY, b.maxY);

        // if clamped into a corner and movement isn't enough, pick farthest corner
        const moved = Math.hypot(nextX - cur.left, nextY - cur.top);
        if (moved < MIN_MOVE_DIST) {
          const corner = pickFarCorner(mouseX, mouseY);
          // add some jitter so it doesn't "stick" exactly on the corner
          nextX = clamp(corner.x + (Math.random() * 2 - 1) * 25, b.minX, b.maxX);
          nextY = clamp(corner.y + (Math.random() * 2 - 1) * 25, b.minY, b.maxY);
        }

        // tiny scoot
        noBtn.style.transform = "scale(1.04)";
        setTimeout(() => (noBtn.style.transform = "scale(1)"), 120);

        return { x: nextX, y: nextY };
      }

      function moveNo(mouseX, mouseY, force = false) {
        startEscaping();
        const now = Date.now();
        if (!force && now - lastMoveAt < COOLDOWN_MS) return;
        lastMoveAt = now;

        const { x, y } = pickNextPosition(mouseX, mouseY);
        noBtn.style.left = x + "px";
        noBtn.style.top = y + "px";
      }

      function handlePointerMove(e) {
        const m = getMouseInCard(e);
        if (m.x < 0 || m.y < 0 || m.x > card.clientWidth || m.y > card.clientHeight) return;

        const r = rectInCard(noBtn);
        const d = distPointToRect(m.x, m.y, r);

        if (d < THRESHOLD) moveNo(m.x, m.y);
      }

      function startEscaping() {
        if (noBtn.classList.contains("noBtnEscaping")) return;
        const r = rectInCard(noBtn);
        const buttons = noBtn.parentElement;
        const spacer = document.createElement("span");
        spacer.setAttribute("aria-hidden", "true");
        spacer.style.cssText = "display:inline-block;width:" + (noBtn.offsetWidth + 12) + "px;height:" + noBtn.offsetHeight + "px;flex-shrink:0;";
        buttons.insertBefore(spacer, noBtn);
        card.appendChild(noBtn);
        noBtn.classList.add("noBtnEscaping");
        noBtn.style.position = "absolute";
        noBtn.style.left = r.left + "px";
        noBtn.style.top = r.top + "px";
      }

      // Mouse + touch support
      card.addEventListener("pointermove", handlePointerMove, { passive: true });

      const HOLD_MS = 1000;

      function setupHoldToActivate(btn, onHoldComplete) {
        let holdTimer = null;
        function clearHold() {
          if (holdTimer) clearTimeout(holdTimer);
          holdTimer = null;
          btn.classList.remove("holding");
        }
        btn.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          if (e.button !== 0) return;
          btn.classList.add("holding");
          holdTimer = setTimeout(() => {
            holdTimer = null;
            btn.classList.remove("holding");
            onHoldComplete();
          }, HOLD_MS);
        });
        btn.addEventListener("pointerup", clearHold);
        btn.addEventListener("pointerleave", clearHold);
        btn.addEventListener("pointercancel", clearHold);
      }

      // No: escape on hover/approach; "click" (message) only after 1s hold
      noBtn.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        message.textContent = "i knew yo ass would try to do this which is why i made it hold to register LOL";
        startEscaping();
        const m = getMouseInCard(e);
        moveNo(m.x, m.y, true);
      });

      noBtn.addEventListener("mouseenter", (e) => {
        startEscaping();
        const m = getMouseInCard(e);
        moveNo(m.x, m.y, true);
      });

      setupHoldToActivate(noBtn, () => {
        message.textContent = "i know yo ass wouldve tried to click (but this should not have happened lol)";
      });

      function playHeartBurst() {
        const container = document.getElementById("heartBurst");
        container.innerHTML = "";
        const count = 24;
        for (let i = 0; i < count; i++) {
          const el = document.createElement("span");
          el.textContent = "â™¥";
          el.style.setProperty("--angle", (360 / count) * i + "deg");
          el.style.animationDelay = (i * 0.02) + "s";
          container.appendChild(el);
        }
        setTimeout(() => { container.innerHTML = ""; }, 1200);
      }

      setupHoldToActivate(yesBtn, () => {
        message.textContent = "Yay! See you on Valentine's Day <3";
        playHeartBurst();
      });

      window.addEventListener("resize", () => {
        if (!noBtn.classList.contains("noBtnEscaping")) return;
        const cur = currentPos();
        const b = safeBounds();
        noBtn.style.left = clamp(cur.left, b.minX, b.maxX) + "px";
        noBtn.style.top = clamp(cur.top, b.minY, b.maxY) + "px";
      });
    </script>
  </body>
</html>